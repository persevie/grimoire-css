# v1.8.0 Runebridge

Grimoire CSS expands both its **core composition model** and its **tooling surface** with **Runebridge**. This release improves scroll composition by adding argument-driven spell selection (`spellByArgs`) and enabling parameterized scroll invocations inside `scrolls[].spells` (e.g. `box=12px`). On top of that, it introduces a Rust **Analyzer**, a feature-gated **LSP server** (stdio), and a first-party **VS Code extension**.

## Key Highlights

- **Scroll composition upgrades**: `spellByArgs` for argument-driven spell selection and parameterized scroll usage inside `scrolls[].spells`.
- **Analyzer (Rust)**: Indexes projects, resolves references, computes stats, runs lints, and explains tokens in a structured, IDE-friendly format.
- **LSP Server (stdio)**: Feature-gated `grimoire_css_lsp` exposes analyzer capabilities via `workspace/executeCommand` for editor integration.
- **VS Code Extension**: A full UI layer (views + actions) with hover insights, highlights, and navigation for spells/scrolls/variables.
- **Scriptable CLI (`fi`)**: Machine-friendly JSON outputs for automation and for sharing the same "commands" between CLI and LSP.
- **Core improvements**: Parser/token extraction hardening, stricter spell validation, config/schema alignment, and optimizer controls.
- **Dev Experience**: Extension CI workflows and repo VS Code tasks/launch configs to make local development repeatable.
- **Additional Binary Name**: The main CLI binary is now also available as `grim` (alongside `grimoire_css`).
- **Updated MSRV**: Minimum supported Rust version is now 1.93.0.

## Full Details

### Scroll Composition Upgrades (Core)

Runebridge improves scroll authoring and composition in core configuration:

- **`spellByArgs`**: Choose spell sets based on invocation arguments for more expressive, reusable scrolls.
- **Parameterized scroll invocations inside `scrolls[].spells`**: You can now put invocations like `box=12px` directly into `scrolls[].spells`.

  This matters because `extend` only supports inheriting by **scroll name**, while many real-world scrolls are _parameterized_. Example: you may have a scroll `box` that accepts args (`box=12px`). Previously you could not create a new scroll whose `spells` include `box=12px`; now you can.

These changes make large style systems easier to model and enable richer analysis/refactoring in IDE tooling.

### Analyzer: Structured CSS Spell Intelligence

The new analyzer provides a reusable set of operations designed to be consumed by both the CLI and IDE clients:

- **Index / Explorer data**: A deterministic snapshot of key entities and their relationships.
- **References**: Find usage of spells, scrolls, and Grimoire variables.
- **Stats**: Usage counts and "what is this token" hints.
- **Explain**: Parse a token into meaningful parts and return structured diagnostics on invalid tokens.
- **Lint**: Detect suspicious or unused configuration-driven entities (policy-based).
- **Dry candidates**: Identify refactoring candidates and optionally generate scroll suggestions.

### LSP Server: IDE Commands over stdio

Runebridge introduces `grimoire_css_lsp` (enabled with `--features lsp`), designed to be embedded by editor extensions.

It focuses on `workspace/executeCommand` to expose analyzer functionality in a stable, versioned command surface.

Canonical command set includes (may evolve):

- `grimoirecss.explorerIndex`, `grimoirecss.entityDetails`
- `grimoirecss.index`, `grimoirecss.lint`, `grimoirecss.refs`, `grimoirecss.explain`, `grimoirecss.stats`
- `grimoirecss.configSummary`, `grimoirecss.documentSpells`
- `grimoirecss.dryCandidates`, `grimoirecss.dryCreateScroll`
- `grimoirecss.listScrolls`, `grimoirecss.listVars`

### VS Code Extension: First-party Editor Integration

The VS Code extension provides a UI and workflow layer on top of the LSP server:

- **Views**: Explorer, Details, Config, Actions, Refs, Problems/Diagnostics, and DRY helpers.
- **Editor UX**: Hover explain, highlights, and code actions that connect tokens to details and refs.
- **Workspace-aware**: Supports selecting the correct root in multi-folder setups.

### `fi`: Scriptable CLI for Automation

The `fi` command provides JSON output suitable for scripts, CI, and editor tooling. It intentionally mirrors LSP capabilities so that CLI and IDE can share the same mental model and (where appropriate) the same command semantics.

### Core Improvements

This release includes meaningful core work that improves correctness and clarity, and also benefits analysis tooling:

- **Parser improvements for token extraction**: better handling of templated tokens, spans/offsets, and edge cases needed for precise refs and hover.
- **Spell parsing/validation tightening**: malformed function-like targets fail earlier with clearer errors.
- **Config + schema alignment**: config FS loading and JSON schema updates to keep tooling outputs consistent.
- **Optimizer controls**: added a path for readable (non-minified) CSS output when tooling needs "pretty" results.

## Migration Notes

### For Users

- **No required workflow changes**: core CSS generation remains available via the standard CLI and crate APIs.
- **Optional IDE stack**: LSP is behind a feature flag; you can avoid its dependencies by not enabling `lsp`.

### For Contributors

- **MSRV**: Development targets Rust 1.93.0+.
- **Extension tooling**: VS Code extension workflows run on Node 20.
